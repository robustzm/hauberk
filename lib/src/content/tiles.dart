import 'package:malison/malison.dart';
import 'package:piecemeal/piecemeal.dart';

import '../engine.dart';
import '../hues.dart';
import 'action/tile.dart';

// Note: Not using lambdas for these because that prevents [Tiles.openDoor] and
// [Tiles.closedDoor] from having their types inferred.
Action _closeDoor(Vec pos) => CloseDoorAction(pos, Tiles.closedDoor);

Action _openDoor(Vec pos) => OpenDoorAction(pos, Tiles.openDoor);

Action _closeBarredDoor(Vec pos) =>
    CloseDoorAction(pos, Tiles.closedBarredDoor);

Action _openBarredDoor(Vec pos) => OpenDoorAction(pos, Tiles.openBarredDoor);

/// Static class containing all of the [TileType]s.
class Tiles {
  // Temporary tile types used during stage generation.

  /// An unformed tile that can be turned into aquatic, passage, or solid.
  static final unformed = tile("unformed", "?", slate).open();

  /// An unformed tile that can be turned into water of some kind when "filled"
  /// or a bridge when used as a passage.
  static final unformedWet = tile("unformed wet", "≈", slate).open();

  /// An open floor tile generated by an architecture.
  static final open = tile("open", "·", gunsmoke).open();

  /// A solid tile that has been filled in the passage generator.
  static final solid = tile("solid", "#", gunsmoke).solid();

  /// An open tile that the passage generator knows must remain open.
  static final passage = tile("passage", "-", gunsmoke).open();

  /// The end of a passage.
  static final doorway = tile("doorway", "○", gunsmoke).open();

  /// An untraversable wet tile that has been filled in the passage generator.
  static final solidWet = tile("solid wet", "≈", cornflower).solid();

  /// A traversable wet tile that the passage generator knows must remain open.
  static final passageWet = tile("wet passage", "-", cornflower).open();

  // Real tiles.

  static final floor = tile("floor", "·", slate).open();
  static final burntFloor = tile("burnt floor", "φ", steelGray).open();
  static final burntFloor2 = tile("burnt floor", "ε", steelGray).open();
  static final rock = tile("rock", "▓", gunsmoke, slate).solid();
  static final wall = tile("wall", "▒", gunsmoke, slate).solid();
  static final lowWall = tile("low wall", "%", gunsmoke).obstacle();
  static final openDoor =
      tile("open door", "○", persimmon, garnet).onClose(_closeDoor).open();
  static final closedDoor =
      tile("closed door", "◙", persimmon, garnet).onOpen(_openDoor).door();

//  TODO: maleSign = open square door ♂
//  TODO: femaleSign = closed square door
  static final openBarredDoor = tile("open barred door", "♂", gunsmoke, slate)
      .onClose(_closeBarredDoor)
      .open();

  // TODO: Should be able to see through but not fly through.
  static final closedBarredDoor =
      tile("closed barred door", "♪", gunsmoke, slate)
          .onOpen(_openBarredDoor)
          .transparentDoor();

  // TODO: Different character that doesn't look like bridge?
  static final stairs = tile("stairs", "≡", gunsmoke, slate).exit().open();
  static final bridge = tile("bridge", "≡", persimmon, garnet).open();

  // TODO: Stop glowing when stepped on?
  static final glowingMoss =
      Tiles.tile("moss", "░", seaGreen).emanate(128).open();

  static final water = tile("water", "≈", cerulean, ultramarine)
      .animate(10, 0.5, ultramarine, midnight)
      .water();
  static final steppingStone =
      tile("stepping stone", "•", gunsmoke, ultramarine).open();

  static final dirt = tile("dirt", "·", garnet).open();
  static final dirt2 = tile("dirt2", "φ", garnet).open();
  static final grass = tile("grass", "░", peaGreen).open();
  static final tallGrass = tile("tall grass", "√", peaGreen).open();
  static final tree = tile("tree", "▲", peaGreen, sherwood).solid();
  static final treeAlt1 = tile("tree", "♠", peaGreen, sherwood).solid();
  static final treeAlt2 = tile("tree", "♣", peaGreen, sherwood).solid();

  static final tableTopLeft = tile("table", "┌", persimmon).obstacle();
  static final tableTop = tile("table", "─", persimmon).obstacle();
  static final tableTopRight = tile("table", "┐", persimmon).obstacle();
  static final tableSide = tile("table", "│", persimmon).obstacle();
  static final tableCenter = tile("table", " ", persimmon).obstacle();
  static final tableBottomLeft = tile("table", "╘", persimmon).obstacle();
  static final tableBottom = tile("table", "═", persimmon).obstacle();
  static final tableBottomRight = tile("table", "╛", persimmon).obstacle();

  static final tableLegLeft = tile("table", "╞", persimmon).obstacle();
  static final tableLeg = tile("table", "╤", persimmon).obstacle();
  static final tableLegRight = tile("table", "╡", persimmon).obstacle();

  static final candle = tile("candle", "≥", sandal).emanate(128).obstacle();

  static final wallTorch =
      tile("wall torch", "≤", gold, slate).emanate(192).solid();

  // TODO: Different glyph.
  static final braziers = multi("brazier", "≤", persimmon, null, 5,
      (tile, n) => tile.emanate(192 - n * 12).obstacle());

  // TODO: Make these do something.
  static final openChest = tile("open chest", "⌠", persimmon).obstacle();
  static final closedChest = tile("closed chest", "⌡", persimmon)
      .onOpen((pos) => OpenChestAction(pos))
      .obstacle();
  static final closedBarrel = tile("closed barrel", "°", persimmon)
      .onOpen((pos) => OpenBarrelAction(pos))
      .obstacle();
  static final openBarrel = tile("open barrel", "∙", persimmon).obstacle();

  static final statue = tile("statue", "P", ash, slate).obstacle();

  // Make these "monsters" that can be pushed around.
  static final chair = tile("chair", "π", persimmon).open();

  static final brownJellyStain =
      tile("brown jelly stain", "·", persimmon).open();

  static final grayJellyStain = tile("gray jelly stain", "·", steelGray).open();

  static final greenJellyStain = tile("green jelly stain", "·", lima).open();

  static final redJellyStain = tile("red jelly stain", "·", brickRed).open();

  static final violetJellyStain =
      tile("violet jelly stain", "·", violet).open();

  static final whiteJellyStain = tile("white jelly stain", "·", ash).open();

  // TODO: Make this do stuff when walked through.
  static final spiderweb = tile("spiderweb", "÷", slate).open();

  static _TileBuilder tile(String name, Object char, Color fore,
          [Color back]) =>
      _TileBuilder(name, char, fore, back);

  static List<TileType> multi(String name, Object char, Color fore,
      Color back, int count, TileType Function(_TileBuilder, int) generate) {
    var result = <TileType>[];
    for (var i = 0; i < count; i++) {
      var builder = tile(name, char, fore, back);
      result.add(generate(builder, i));
    }

    return result;
  }

  /// The amount of heat required for [tile] to catch fire or 0 if the tile
  /// cannot be ignited.
  static int ignition(TileType tile) => _ignition[tile] ?? 0;

  static final _ignition = {
    openDoor: 30,
    closedDoor: 30,
    bridge: 50,
    glowingMoss: 10,
    grass: 3,
    tallGrass: 3,
    tree: 40,
    treeAlt1: 40,
    treeAlt2: 40,
    tableTopLeft: 20,
    tableTop: 20,
    tableTopRight: 20,
    tableSide: 20,
    tableCenter: 20,
    tableBottomLeft: 20,
    tableBottom: 20,
    tableBottomRight: 20,
    tableLegLeft: 20,
    tableLeg: 20,
    tableLegRight: 20,
    openChest: 40,
    closedChest: 80,
    openBarrel: 15,
    closedBarrel: 40,
    candle: 1,
    chair: 10,
    spiderweb: 1
  };

  /// How long [tile] burns before going out.
  static int fuel(TileType tile) => _fuel[tile] ?? 0;

  static final _fuel = {
    openDoor: 70,
    closedDoor: 70,
    bridge: 50,
    glowingMoss: 20,
    grass: 30,
    tallGrass: 50,
    tree: 100,
    treeAlt1: 100,
    treeAlt2: 100,
    tableTopLeft: 60,
    tableTop: 60,
    tableTopRight: 60,
    tableSide: 60,
    tableCenter: 60,
    tableBottomLeft: 60,
    tableBottom: 60,
    tableBottomRight: 60,
    tableLegLeft: 60,
    tableLeg: 60,
    tableLegRight: 60,
    openChest: 70,
    closedChest: 80,
    openBarrel: 30,
    closedBarrel: 40,
    candle: 60,
    chair: 40,
    spiderweb: 20
  };

  /// What types [tile] can turn into when it finishes burning.
  static List<TileType> burnResult(TileType tile) {
    if (_burnTypes.containsKey(tile)) return _burnTypes[tile];

    return [burntFloor, burntFloor2];
  }

  static final _burnTypes = {
    bridge: [water],
    grass: [dirt, dirt2],
    tallGrass: [dirt, dirt2],
    tree: [dirt, dirt2],
    treeAlt1: [dirt, dirt2],
    treeAlt2: [dirt, dirt2],
    candle: [tableCenter],
    spiderweb: [floor]
  };
}

class _TileBuilder {
  final String name;
  final List<Glyph> glyphs;

  Action Function(Vec) _onClose;
  Action Function(Vec) _onOpen;
  bool _isExit = false;
  int _emanation = 0;

  factory _TileBuilder(String name, Object char, Color fore, [Color back]) {
    back ??= midnight;
    var charCode = char is int ? char : (char as String).codeUnitAt(0);

    return _TileBuilder._(name, Glyph.fromCharCode(charCode, fore, back));
  }

  _TileBuilder._(this.name, Glyph glyph) : glyphs = [glyph];

  _TileBuilder animate(int count, double maxMix, Color fore, Color back) {
    var glyph = glyphs.first;
    for (var i = 1; i < count; i++) {
      var mixedFore =
          glyph.fore.blend(fore, lerpDouble(i, 0, count, 0.0, maxMix));
      var mixedBack =
          glyph.back.blend(back, lerpDouble(i, 0, count, 0.0, maxMix));

      glyphs.add(Glyph.fromCharCode(glyph.char, mixedFore, mixedBack));
    }

    return this;
  }

  _TileBuilder emanate(int emanation) {
    _emanation = emanation;
    return this;
  }

  _TileBuilder exit() {
    _isExit = true;
    return this;
  }

  _TileBuilder onClose(Action Function(Vec) onClose) {
    _onClose = onClose;
    return this;
  }

  _TileBuilder onOpen(Action Function(Vec) onOpen) {
    _onOpen = onOpen;
    return this;
  }

  TileType door() => _motility(Motility.door);

  TileType transparentDoor() => _motility(Motility.fly | Motility.door);

  TileType obstacle() => _motility(Motility.fly);

  TileType open() => _motility(Motility.flyAndWalk);

  TileType solid() => _motility(Motility.none);

  TileType water() => _motility(Motility.fly | Motility.swim);

  TileType _motility(Motility motility) {
    return TileType(name, glyphs.length == 1 ? glyphs.first : glyphs, motility,
        emanation: _emanation,
        isExit: _isExit,
        onClose: _onClose,
        onOpen: _onOpen);
  }
}
